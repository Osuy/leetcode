#pragma once
/*
	单调栈的用途比较小，仅适用于寻找每个元素的下一个更大/更小小的元素
	假设要求的是寻找每个元素的下一个更大元素
	从第i个元素往右看去，会看到一个类似“目”的结构
	由于小的元素都被挡住了，只能看到更大的元素，所以所看到的元素是单调递增的
	对于元素i，它的下一个更大元素就是它所在的矩形的上面的矩形所代表的元素
	也即：如果有一个数据结构维护了这些单调递增的元素，并且i不在其中，那么
	i的下一个更大元素就是该数据结构的第一个元素，然后将i也假如到它的首部
	然后下一个循环该往前走还是往后走呢？
	既然这个数据结构维护的是i后面的元素，并且i可能也会添加进去用以求i-1的答案
	那么就应该是往前遍历，于是对于i-1，它只需于首部元素比较
	那i怎么没有比较？i也需要比较，为了让数据结构保持单调，必然只有比较后更小的元素才能插入首部
	如果i比首部大，则需要移出首部元素，直到比首部小或容器为空
	发现移出操作所移出的元素，一定是更晚才进来的，因此具有后进先出的特点

	入栈的规则是始终比栈顶大/小，如果不满足，出栈直到满足或栈空
	因为对于一个无序的数组而言，加载两个更大的值中间的小值，永远不可能是外面的元素的答案
	所以将这些小值出栈，保持栈是单调递增的，且每次出栈/入栈，相关的元素就能得到答案
	即，对于元素i，它的下一更大元素，需要用递增的视角去看余下的数组，所以先暂时保存在栈里
	直到入栈一个更大的元素，说明它的答案找到了，将他出栈

	模板：
	int n = nums.size();
	vector<int> res(n);
	stack<int> s;
	for (int i = n - 1; i >= 0; i--) {
		// 判定个子高矮
		while (!s.empty() && s.top() <= nums[i]) {
			// 矮个起开，反正也被挡着了。。。
			s.pop();
		}
		// nums[i] 身后的更大元素
		res[i] = s.empty() ? -1 : s.top();
		s.push(nums[i]);
	}
	return res;

	要点1：从后往前遍历，因为求的是下一个，所以后方是已知区间。如果要求“上一个更XX的元素”，改为正序遍历
	要点2：内循环的出栈条件是大于等于栈顶，如果是寻找下一个大于或等于，则改为小于即可


	有从左往右和从右往左两种解法
	例如：数组{ 1，7，4，5，3，3，9，2}，求每个元素的下一个更大元素

	从左往右，出栈时得到答案
		1入栈
		7，比栈顶大，出栈
			1出栈，且 1的下一个更大元素就是7
			7入栈7
		4比栈顶7小，入栈74
		5比栈顶4大，出栈
			4出栈7，且4的下一更大元素是5
			5入栈75
		3比栈顶小，入栈753
		3比栈顶相等，入栈7533
		9比栈顶大，出栈
			3出栈753，3的下一更大元素是9
			3出栈75，3的下一更大元素是9
			5出栈7，5的下一更大元素是9
			7出栈，7的下一更大元素是9
			9入栈9
		2比栈顶小，入栈92
	答案：795999-1-1

	{ 1，7，4，5，3，3，9，2}
	从右往左，入栈时得到答案
		2入栈
		9比栈顶2大，出栈
			2出栈
			9入栈 9
		3比栈顶小，入栈
			3入栈93， 3的下一更大元素是9
		3比栈顶相等，
			3出栈9，
			3入栈93，3的下一更大元素是9
		5比栈顶3大，出栈
			3出栈9，
			5入栈59，5的下一更大元素是9
		4比栈顶小，入栈
			4入栈954，4的下一更大元素是5
		7比栈顶大，出栈
			4出栈95，
			5出栈9
			7入栈97，7的下一更大元素是9
		1比栈顶小，入栈
			1入栈971，1下一更大元素是7
		795999-1-1


*/