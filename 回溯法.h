#pragma once

/*

*/

/*
	组合/子集
		从数组中选取若干元素，选取的顺序无关
		逐个选取元素，直至数组内的元素达成某条件
		求所有满足条件的选取方式
		子集/组合由于不考虑顺序，所以选取结构是三角形
		即某次选了元素i后，下一层选择要从i+1开始
		如果从0开始就会出现：
			选了i再选了j
			选了j再选了i
		两种情况，发生重复。

	排列
		选取若干元素，选取的顺序有关，并且一般要求固定长度
		逐个选取元素，直至长度达到某值
		并且要求选取顺序不重复，求所有顺序
		由于顺序不同视为不同的排列，所以对于：
			选了i再选了j
			选了j再选了i
		视为两种不同的排列，都要考虑，因此排序的递归在
		某层选了i后，下一层要从0开始（于是传参i也可以省略了），并且要跳过已选的元素
		所以就需要用used数组来维护所有元素的使用情况
		（子集/组合不用是因为i的下一层从i+1开始，自然是未使用过的）

	
	以上是对于：元素无重复不可复选的题目的通用解法，还需要注意两种变体：
		元素可重复不可复选
		元素无重复可复选
	为什么没有可重复可复选？因为某个元素可复选，它又是重复的，那么无论复选那个都一样
	也就可以直接去重，把问题转化未无重复可复选

	元素可重复不可复选
		因为有元素重复，组合/子集里的一部分就会重复
		（某两个子集，其他所有元素一样，一个选了i，一个选了i'，但是被视为同一个子集，如果不剔除就过不了题解）
		而我们并不知道和i相等的元素i'在哪里，于是需要排序，让它们相邻
		然后在选取时，对于相邻且相同的元素，只选一个（第一个或最后一个，第一个比较好写）
		即：
			if(j > i && nums[j] == nums[j-1])continue;
			必须是大于i而不是大于0。因为要剔除的是这一层循环里的重复元素，所以j和j-1都要在可选元素内
			j从i开始循环，j-1即i-1不是这一层范围内的元素
			例如，上一层循环选了i，这一层循环i'是可选的（要通过i'的是上一层），但是如果是j>0
			那么j-1就会判断 i和i'相等然后跳过

		对于排列问题，因为也要跳过相同元素，所以也需要排序
		某一层选了i，，used[i] = true，并且跳过后续相同的i'
		不同之处在于：对于后续层 i'是可选的，但是由于 i' == i（i'-1）所以i'也会被跳过
		所以在跳过时的判断不是“与前一个相同”，而是“与前一个未用过的相同”
		（谨记：从0开始循环和used数组是排列的核心）
		于是就要写成：
			if(j > 0 && nums[j] == nums[j-1] && ！used[j-1])continue;

	无重复可复选
		子集/组合是通过迭代i后的下一层迭代i+1达到不复选的效果的
		而既然可复选，只要下一层仍然从i开始迭代即可。
		为什么不是从0开始？
		因为与其所每一层迭代是求包含i的集合，不如说是求不包含[0~i-1]的集合
		因为前面的层已经包含过[0~i-1]了。这是一个>的操作。反过来就是<=
		如果从i+1开始迭代下一层，就是<。而可复选就是<=
		因此j从i开始迭代就可以实现复选
		因为可复选，所以迭代会无限下去。因此可复选的题目本身还会施加限制，如长度、总和

		对于排列问题，如果可重选，那么就用不到used数组，n个元素的排列就是n^n种

	总结：
		子集/组合问题，每层加入未迭代的元素，所以递归传i+1。如果元素有重复，排序，然后跳过这一层里的重复项
			如果选取可重复，则递归传i，使下一层仍能选到i

		排列问题，每层加入未使用元素，于是需要used数组记录使用情况。如果元素有重复，排序，然后跳过未使用的重复项
			如果选取可重复，则无需记录used
*/