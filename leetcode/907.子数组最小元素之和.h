#pragma once

/*
	难度中等

	对于数组，其所有（连续）子数组的 最小元素 求和

	对于某个元素 el ，如果它是以[i,j)为左右边界的子数组的最小元素，则将它累加到答案里

	分析
		假设el[x]恰好是区间[i,j)内的最小元素，且 el[i-1] 和 el[j]都比el[x]小于等于
		则所有以el[x]为最小元素的数组都是[i,j)的子数组，其个数为 (x-i+1)*(j-x)
		为了简化边界值判断，使用前开后开区间(i,j)，则数量为(x - i) * (j - x)
		则el[x]的会在最终结果里出现这么多此，相当于累加el[x] * (x - i) * (j - x)
		由于el[x] 依赖于 x ，所以只需要 i\j\x 三个值即可。而三者都是索引
		并且i<x<j;
		那么当从左向右遍历数组时，可以用额外的数组来保存i和x，当遇到 el[x]>=el[j]时取出ixj进行计算
		而i<x,而i本身也是曾经的 x，所以可以保存在一个数组里，且数组是单调递增的

		但是ix如何确定呢？
		j 遍历数组，如果 el[j] 大于el[arr.back()]，则j存入数组
		负责




	[11,81,94,43,3]

	11入栈11
	81比栈顶11大，入栈11 81
	94比栈顶81大，入栈 11 81 94
	43比栈顶94小，说明以94为最小元素的子数组结束了，计算结果
		94出栈，94*（43的索引3 - 94的索引2 =  1）*（94的索引2 - 栈顶81的索引 1 =  1） = 94*1= 94
		43比栈顶81小，说明以81为最小元素的子数组结束了，计算结果
		81出栈，81*（43的索引3 - 81的索引1）*（81的索引1 - 栈顶11的索引0） =  81*2 = 162
		43入栈11 43
	3比栈顶43小，说明以43为最小元素的子数组结束了，计算结果
		43出栈， 43*（3的索引4 - 43的索引3）* （43的索引3 - 栈顶11索引0） = 43*3 =  129
		3比栈顶11小，说明以11为最小元素的子数组结束了，计算结果
		11出栈，11*（3的索引4 - 11的索引0）* （11的索引0 -  空栈-1） = 11*4 =  44
		3入栈3
	无元素，试着入栈-1
		-1比栈顶3小，说明以3为最小元素的子数组结束了，计算结果
		3出栈， 3*（3的索引4-空栈-1）*（-1的索引5-3的索引4） =  3*5 =  15

*/