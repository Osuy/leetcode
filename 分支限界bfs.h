#pragma once

/*
	用于求解问题树的最短路径

	问题可以被分割为树：从起点开始，有几种可能。每种可能又对应着几种子可能，如此递归。。。。
	考虑队列元素：需要记录什么信息，以供下一层的子可能去处理
	考虑剪枝：遇到无效或重复的可能如何跳过

	优化：
		如果事先直到终点，求最短路径，可以用双向bfs，同时从起点和终点开始bfs
		不再使用队列而是使用两个hashset，每次求相邻元素后，判断元素是否在另一个集合里，如果有
		则说明两个集合产生交集，得到答案
*/