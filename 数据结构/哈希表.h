#pragma once
/*
	原理：将元素通过hash函数转化位索引，在将索引映射到数组上
	得到的索引可能大于数组长度，所以需要映射。从而使任意大小的索引都能用于定长数组
	因为是操作的底层是数组，所以只要hash函数的时间、空间复杂度不超过O(1)，那么访问操作是O(1)

	哈希冲突
	由于大的索引映射到小的数组上，必然会存在两个索引映射到一个位置
	解决方法：
		拉链法：数组不直接存储元素，而是存储链表，多个映射到同一位置的元素存放在链表中
		开放寻址法/线性探测法：如果位置被占，寻找下一个位置，直到没有被占

	负载因子：哈希表size / 哈希表容量（长度）
	负载因子越大，越容易发生哈希冲突
	所以当负载因子达到某一设定好的值时，应当采取扩容
	和数组扩容是一样的，但是由于映射是依赖哈希表长度的，所以一旦扩容，需要重新计算所有元素的索引映射
	这一步相当于数组扩容时的拷贝，只不过数组的元素是一对一的，不用做任何处理

	必须使用常量作为key。key如果变化，hash索引也变化，从而定位失败或错误

	不能依赖哈希表元素的顺序
	因为哈希表增删后可能扩容，元素的顺序发生变化
	所以无法得到相同的顺序

	不要在循环中增删元素。不止是哈希表，所有容器都不适合在循环中增删元素。因为可能发生迭代器失效或变化的问题
	除非对底层实现有了解。例如链表，可以放心在循环中增删，数组如果在当前元素后增删，迭代器不变，如果在当前元素前增删
	迭代器就会失效

	哈希链表/hashset
	为了解决哈希表遍历顺序不一致的问题，因为hash本身的乱序存储以及使用拉链法等问题，是不支持排序的
	那么可用的固定顺序只有插入时的顺序，即如何才能以插入顺序来遍历哈希表呢？
	额与链表结合，每当插入元素时，插入哈希表，也插入到链表。这样无论哈希表怎么扩容，元素间的前后顺序不变
	当然这样存在两份元素，所以可以让哈希表的节点自己作为链表节点，即增加pre next指针
	哈希链表额外有head和tail两个指针，当插入新元素时，不仅插入到哈希表中，还与tail建立链接
	你可以从两个方面去理解
		哈希表主体，节点是含有pre和next，元素插入时的链接到tail，保持前后顺序，隐含了一个链表
		链表主体，新元素总是尾插，新元素保持在哈希表的空位上，无需从头开始访问某个节点，加速了访问
	
	那么来观察各个操作的时间复杂度：
		访问和修改：利用哈希表来访问，O(1)
		插入：插入哈希表O(1)，插入链表末尾O(1)
		删除：删除哈希表元素O(1)，根据pre和next指针删除链表元素O(1)


	你可能会想：既然只是在尾部插入，是不是可以用数组而不用链表？
	但是由于需要删除元素，对数组删除要挪动其他元素，会牺牲时间复杂度
	而如果将要删除的元素与末尾互换再删除，会使顺序打乱。
	因此如果要用数组，就又要回到无序遍历状态。（也是有优点的，数组的遍历缓存命中率更高）
*/