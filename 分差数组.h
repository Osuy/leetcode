#pragma once
/*
	一种将“对连续子数组的操作”转为“对区间的操作”的方法
	可以减少一层循环，通常用于动态规划的题目中

	分差是求和的逆运算。

	对分差数组进行前N项求和，可以得到原数组。
	而求前N项和是一个经典的动态规划

	所以 连续数组 + 分差 + 动态规划 是一套解题的技巧
	如果单纯的动态规划无法找到子问题公式，可以进一步用分差来寻找子问题
	
	适用的题目一般有以下特征：
		区间或连续子数组
		需要对区间内的所有元素做同样的操作
		要求解的答案是一个值或bool
*/

// 对于数组，求分差数组：diff[0] = a[0]; diff[i] = a[i] - a[i - 1];
int a1[5] = {1,3,3,5,8};
int diff1[5] = { 1,2,0,2,3 };//对diff求前N项和可以得到： 1 3 3 5 8 即原数组a

// 如果把连续子数组a[1~3]加上10，则有
int a2[5] = { 1,13,13,15,8 };
int diff2[5] = { 1,12,0,2,-7 };

// 对比两个diff，只有[1]和[4]改变，且[1]+10,[4]-10。刚好[1, 4)是修改的连续子数组的前闭后开区间
// { 0, 10, 0, 0. -10}
// 对diff差数组求前n项和，得到{0,10,10,10,0}
