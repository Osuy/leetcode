#pragma once
/*
	一种将“对连续子数组的操作”转为“对区间的操作”的方法
	可以减少一层循环，通常用于动态规划的题目中

	diff[0] = arr[0]
	diff[i] = arr[i] - arr[i-1]

	分差是前缀和的逆运算
	对分差数组求前缀和，可以得到原数组
	presum[0] = diff[0] = arr[0];
	presum[i] = presum[i-1]+diff[i] = diff[0] + diff[1] + ... + diff[i] = arr[0] + diff[1] + .... + diff[i]
		= arr[1] + diff[2] + ... + diff[i] = arr[i-1] + diff[i] = arr[i]

	如果将diff[i] += n, 表现为其前缀和/原数组的i以及后面的所有元素都会增加n
	（某一项变大，求前缀和后其后面的所有项都变大）
	而如果将diff[j+1]-=n,则原数组区间[i,j]内的所有元素都变大n
	（i以后的增加n，j+1以后的减小n，结合起来就是i、j之间的增加n，其余不变）

	
	适用的题目一般有以下特征：
		区间或连续子数组
		需要对区间内的所有元素做同样的操作
*/

// 对于数组，求分差数组：diff[0] = a[0]; diff[i] = a[i] - a[i - 1];
int a1[5] = {1,3,3,5,8};
int diff1[5] = { 1,2,0,2,3 };//对diff求前N项和可以得到： 1 3 3 5 8 即原数组a

// 如果把连续子数组a[1~3]加上10，则有
int a2[5] = { 1,13,13,15,8 };
int diff2[5] = { 1,12,0,2,-7 };

// 对比两个diff，只有[1]和[4]改变，且[1]+10,[4]-10。刚好[1, 4)是修改的连续子数组的前闭后开区间
// { 0, 10, 0, 0. -10}
// 对diff差数组求前n项和，得到{0,10,10,10,0}
